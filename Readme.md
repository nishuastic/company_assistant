# LinkedIn Generator and Value App

This project combines two functionalities into a single streamlined application:
1. **LinkedIn Generator**: Create professional and concise LinkedIn connection notes.
2. **Competitor Analysis (Value App)**: Analyzes competitors' websites to extract relevant pages and generate insights about pricing, sales channels, value propositions, and more.

---

## Architecture Overview

### 1. **Core Components**
- **Streamlit UI**: Provides an interactive interface for user input and result display.
- **FastAPI Backend**: Handles API requests for both Value App and LinkedIn Note Generator.
- **OpenAI Integration**: Uses GPT models for text analysis, title relevance checks, summarization, and generating LinkedIn notes.
- **LangChain**: Processes and indexes website data for contextual question-answering capabilities.

### 2. **Agent Workflow**

#### Competitor Analysis (Value App)
1. **Input**: The user provides a competitor's website URL.
2. **Homepage Crawling**:
   - The system crawls the homepage, extracting URLs and titles of pages.
   - Each URL is validated to ensure it belongs to the same domain.
3. **Title Analysis**:
   - Page titles are sent to the OpenAI GPT model.
   - The model identifies relevant titles based on their potential utility (e.g., pricing, product launches, value propositions).
4. **Content Extraction**:
   - Relevant pages are fetched, and their content is extracted and cleaned using BeautifulSoup.
   - Extracted content is saved in a local cache to avoid redundant processing.
5. **LangChain Indexing**:
   - The cleaned content is split into manageable chunks using `CharacterTextSplitter`.
   - A FAISS vector store is created with OpenAI embeddings to enable efficient similarity-based searches.
6. **Question Answering**:
   - The user can ask questions related to the analyzed content via a chatbot.
   - Relevant chunks are retrieved using LangChain's similarity search.
   - OpenAI GPT generates a summarized response based on the retrieved content.

#### LinkedIn Note Generator
1. **Input**: The user provides recipient details (name, headline, about section, purpose) and sender name.
2. **Prompt Construction**:
   - A detailed prompt is generated for OpenAI GPT, incorporating the user's inputs.
3. **Response Generation**:
   - OpenAI GPT generates a concise, professional connection note tailored to the provided context.
4. **Output**: The note is displayed in the Streamlit UI for the user.

---

## Decision-Making Process

### **Competitor Analysis**
1. **Relevance Filtering**:
   - GPT's natural language understanding evaluates page titles for their relevance.
   - The decision to include a page is based on whether the title aligns with key business insights.
2. **Dynamic Summarization**:
   - When answering user queries, the agent retrieves the most relevant chunks of content.
   - GPT generates a focused summary based on the question, ensuring concise and useful responses.

### **LinkedIn Note Generation**
- **Personalization**:
  - The agent identifies key details from the recipient's profile (headline, about section).
  - These details are used selectively to align with the connection's purpose.
- **Tone Analysis**:
  - GPT ensures the note maintains a polite, professional, and concise tone.
- **Efficiency**:
  - Redundant or irrelevant information is excluded, focusing solely on the connection's purpose.

---

## Features

### LinkedIn Generator
- Generate personalized LinkedIn connection notes based on the recipient's details, purpose of connection, and sender's information.
- AI-powered generation ensures the message is concise, polite, and professional.

### Value App
- **Website Analysis**: Crawl competitor websites and analyze page titles to find relevant sections like pricing, blogs, and about pages.
- **Content Extraction**: Fetch and clean text content from relevant pages.
- **AI-Powered Q&A**: Create a searchable context using LangChain and FAISS to allow questions about the extracted content.
- **AI Summarization**: Generate concise summaries of the answers to user queries.

---

## Installation

### Prerequisites
- Python 3.8 or later
- Environment variable for OpenAI API key (`OPENAI_API_KEY`) must be set.

### Clone the Repository
```bash
git clone https://github.com/nishuastic/company_assistant.git
cd company_assistant
```

### Running
1. Start the Backend Server. The backend is built using FastAPI. Start the server with:
```bash
uvicorn app.main:app --reload
```
By default, it runs at http://localhost:8000.

2. Start the Streamlit UI. The frontend is built using Streamlit. Start the UI with:
```bash
streamlit run ui/streamlit_ui.py
```
The UI will open in your default browser, typically at http://localhost:8501

# Evaluation Framework

Ensure the accuracy and relevance of the content retrieved and responses generated by the Value App.
Evaluate the personalization and conciseness of the LinkedIn Note Generator.
Measure efficiency and usability of the system under various use cases.

## Metrics for Agent's Performance

### **1. Value App Metrics**

- Percentage of relevant pages identified during crawling (compared to a human-labeled ground truth).
- Precision and recall of the page relevance analysis by OpenAI.
- Percentage of correct responses to user queries (evaluated by human reviewers).
- Average response time for crawling, relevance analysis, and chatbot query processing.

### **2. LinkedIn Note Generator Metrics**

- Percentage of notes that include relevant and specific details from the provided inputs.
- Average word count of generated notes.
- Percentage of notes rated as "clear" and "concise" by human reviewers.
- Sentiment analysis score to ensure the notes maintain a polite tone.

### Implmentation Examples: 

#### 1. Compare pages identified as relevant by the system with a human-annotated dataset.

```python
def evaluate_page_relevance(system_relevant_titles, ground_truth_titles):
    true_positives = len(set(system_relevant_titles) & set(ground_truth_titles))
    precision = true_positives / len(system_relevant_titles)
    recall = true_positives / len(ground_truth_titles)
    return {"precision": precision, "recall": recall}
```
#### 2. Accuracy of Content Summarization

Method: Use BLEU or ROUGE scores to compare chatbot responses with reference summaries.

```python
from rouge import Rouge
def evaluate_summary_accuracy(system_summary, reference_summary):
    rouge = Rouge()
    scores = rouge.get_scores(system_summary, reference_summary)
    return scores
```
#### 3. Measure the time taken for each operation (crawling, relevance analysis, and query processing).
```python
import time

def measure_response_time(func, *args, **kwargs):
    start_time = time.time()
    result = func(*args, **kwargs)
    end_time = time.time()
    return {"result": result, "time_taken": end_time - start_time}
```
#### 4. Check if notes include specific details from the inputs (e.g., recipient name, headline).

```python
def evaluate_note_personalization(note, inputs):
    relevant_phrases = [inputs["recipient_name"], inputs["recipient_headline"], inputs["purpose"]]
    matched_phrases = [phrase for phrase in relevant_phrases if phrase in note]
    personalization_score = len(matched_phrases) / len(relevant_phrases)
    return personalization_score
```
#### 5. Use sentiment analysis tools to evaluate the tone of generated notes.
```python
from textblob import TextBlob

def evaluate_note_sentiment(note):
    sentiment = TextBlob(note).sentiment
    return {"polarity": sentiment.polarity, "subjectivity": sentiment.subjectivity}
```

### **Evaluation Plan**

#### Data Collection

##### For Value App:
Crawl multiple competitor websites and collect human-labeled relevance data for pages and summaries.
Simulate user queries and collect reference answers for each.

##### For LinkedIn Note Generator:
Provide diverse input sets with varying levels of detail.
Collect human ratings for generated notes based on personalization, clarity, and politeness.

#### Testing Scenarios

#### Test under different conditions:
Websites with varying structures (e.g., simple, deeply nested pages).
Queries with differing levels of complexity.
Recipients with diverse LinkedIn profiles.

```python
def evaluate_agent(base_url, linkedin_inputs, reference_summaries, note_references):
    # Step 1: Evaluate Value App
    filtered_content = process_value_app_logic(base_url)
    vectorstore = create_langchain_context(filtered_content)

    # Query Accuracy
    query_results = query_vectorstore(vectorstore, "What is the pricing model?")
    accuracy_scores = evaluate_summary_accuracy(query_results, reference_summaries)

    # Step 2: Evaluate LinkedIn Note Generator
    generated_note = generate_note(linkedin_inputs)
    personalization_score = evaluate_note_personalization(generated_note, linkedin_inputs)
    sentiment_scores = evaluate_note_sentiment(generated_note)

    # Report Results
    return {
        "value_app": {"accuracy_scores": accuracy_scores},
        "linkedin_note_generator": {
            "personalization_score": personalization_score,
            "sentiment_scores": sentiment_scores,
        }
    }
```
